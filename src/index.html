<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>Sysproxy Demo</title>
    <style>
      :root {
        font-family:
          system-ui,
          -apple-system,
          "Segoe UI",
          sans-serif;
        color-scheme: light dark;
      }
      body {
        margin: 0;
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-weight: 600;
      }
      input {
        padding: 8px 10px;
        font-size: 14px;
        border-radius: 6px;
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 14px;
        font-size: 14px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background: #2563eb;
        color: #fff;
      }
      button.secondary {
        background: #6b7280;
      }
      #status {
        min-height: 20px;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <h2>设置系统代理</h2>
    <label>
      代理 IP
      <input id="host" placeholder="例如 127.0.0.1" value="127.0.0.1" />
    </label>
    <label>
      代理端口
      <input id="port" type="number" placeholder="例如 7890" value="7890" />
    </label>
    <div style="display: flex; gap: 10px">
      <button id="apply">应用代理</button>
      <button id="restore" class="secondary">恢复原代理</button>
    </div>
    <label>
      原代理配置（JSON，首次保存后显示）
      <textarea
        id="saved"
        rows="12"
        readonly
        style="
          width: 100%;
          font-family:
            ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
            &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;
        "
      ></textarea>
    </label>
    <label>
      当前系统代理（JSON）
      <div style="display: flex; gap: 8px; align-items: center">
        <button id="current">获取当前代理</button>
        <span
          id="current-status"
          style="font-size: 12px; color: #6b7280"
        ></span>
      </div>
      <textarea
        id="current-text"
        rows="12"
        readonly
        style="
          width: 100%;
          font-family:
            ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
            &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;
        "
      ></textarea>
    </label>
    <div id="status"></div>

    <script type="module">
      // --- DOM 元素获取 ---
      const hostInput = document.getElementById("host");
      const portInput = document.getElementById("port");
      const status = document.getElementById("status");

      // --- UI 更新函数 ---

      /**
       * 渲染底部状态消息
       * @param {string} text - 要显示的消息文本
       * @param {boolean} [isError=false] - 是否为错误消息（用于设置颜色）
       */
      const renderStatus = (text, isError = false) => {
        status.textContent = text;
        status.style.color = isError ? "#dc2626" : "#16a34a";
      };

      /**
       * 将数据显示在“原代理配置”文本域中
       * @param {object | null} data - 从后端获取的代理配置对象
       */
      const renderSaved = (data) => {
        const saved = document.getElementById("saved");
        saved.value = data ? JSON.stringify(data, null, 2) : "";
      };

      /**
       * 将数据显示在“当前系统代理”文本域中
       * @param {object | null} data - 从后端获取的代理配置对象
       * @param {string} [msg=""] - 显示在旁边的状态文本，如“加载中...”
       */
      const renderCurrent = (data, msg = "") => {
        const el = document.getElementById("current-text");
        el.value = data ? JSON.stringify(data, null, 2) : "";
        const st = document.getElementById("current-status");
        st.textContent = msg;
      };

      // --- Tauri 后端通信 ---

      // 全局变量，用于缓存 Tauri API 函数，避免重复加载
      let tauriBridge = null;
      // 用于防止重复初始化
      let bridgeInitPromise = null;

      /**
       * 动态加载并返回 Tauri 的 `invoke` 函数。
       * 这是与后端 Rust 命令通信的核心函数。
       * 函数会尝试多种方式加载 API，以兼容不同环境。
       * @returns {Promise<Function|null>}
       */
      const loadInvokeFn = async () => {
        if (window.__TAURI__?.core?.invoke) {
          return window.__TAURI__.core.invoke;
        }
        const candidates = [
          "tauri://localhost/.tauri/api.js",
          "/.tauri/api.js",
        ];
        for (const url of candidates) {
          try {
            const api = await import(url);
            if (api?.invoke) return api.invoke;
            if (api?.core?.invoke) return api.core.invoke;
          } catch (e) {
            console.warn("load tauri core failed", url, e);
          }
        }
        return null;
      };

      /**
       * 动态加载并返回 Tauri 的 `listen` 函数。
       * 这是监听后端 Rust 事件的核心函数。
       * @returns {Promise<Function|null>}
       */
      const loadListenFn = async () => {
        if (window.__TAURI__?.event?.listen) {
          return window.__TAURI__.event.listen;
        }
        const candidates = [
          "tauri://localhost/@tauri-apps/api/event",
          "tauri://localhost/.tauri/api.js",
          "/.tauri/api.js",
        ];
        for (const url of candidates) {
          try {
            const mod = await import(url);
            if (typeof mod?.listen === "function") {
              return mod.listen;
            }
            if (typeof mod?.event?.listen === "function") {
              return mod.event.listen;
            }
          } catch (e) {
            console.warn("load tauri event failed", url, e);
          }
        }
        return window.__TAURI__?.event?.listen ?? null;
      };

      /**
       * 确保 Tauri 的 invoke 和 listen 函数已加载并可用。
       * 使用单例模式确保初始化逻辑只执行一次。
       * @returns {Promise<{invoke: Function, listen: Function}|null>}
       */
      const ensureTauriBridge = async () => {
        if (tauriBridge) return tauriBridge;
        if (bridgeInitPromise) return bridgeInitPromise;

        bridgeInitPromise = (async () => {
          const invoke = await loadInvokeFn();
          if (!invoke) {
            renderStatus("未检测到 Tauri 注入，请用 `pnpm dev` 启动", true);
            return null;
          }

          const listen = await loadListenFn();
          tauriBridge = { invoke, listen };
          return tauriBridge;
        })();

        const bridge = await bridgeInitPromise;
        if (!bridge) {
          bridgeInitPromise = null;
        }
        return bridge;
      };

      /**
       * 获取 `invoke` 函数的便捷方法。
       * @returns {Promise<Function|null>}
       */
      const getInvoke = async () => {
        const bridge = await ensureTauriBridge();
        return bridge?.invoke ?? null;
      };

      // --- 业务逻辑函数 ---

      /**
       * 调用后端命令 `get_saved_proxy` 并更新 UI。
       */
      const refreshSaved = async () => {
        const invoke = await getInvoke();
        if (!invoke) return;
        try {
          const data = await invoke("get_saved_proxy");
          renderSaved(data);
        } catch (e) {
          console.warn("get_saved_proxy failed", e);
        }
      };

      /**
       * 设置监听器以接收来自后端的代理变化事件。
       */
      const setupProxyChangeListener = async () => {
        console.log("设置代理变化监听器...");
        const bridge = await ensureTauriBridge();
        if (!bridge?.listen) {
          console.warn("proxy listener missing tauri event API");
          return;
        }
        try {
          // 监听 "proxy-changed" 事件
          await bridge.listen("proxy-changed", (event) => {
            console.log("收到 proxy-changed 事件:", event);
            if (event?.payload) {
              renderCurrent(event.payload, "监听到系统代理变化");
            }
          });
          console.log("代理变化监听器设置成功");

          // 监听器设置成功后，立即获取一次当前代理信息以作初始化显示
          const invoke = await getInvoke();
          if (invoke) {
            try {
              const data = await invoke("get_current_proxy");
              renderCurrent(data, "初始加载");
              console.log("初始代理信息已加载:", data);
            } catch (e) {
              console.warn("获取初始代理信息失败", e);
            }
          }
        } catch (e) {
          console.warn("failed to listen proxy changes", e);
        }
      };

      // --- 事件监听器绑定 ---

      // “应用代理”按钮点击事件
      document.getElementById("apply").addEventListener("click", async () => {
        const invoke = await getInvoke();
        if (!invoke) return;
        const host = hostInput.value.trim();
        const port = Number(portInput.value);
        if (!host || Number.isNaN(port) || port <= 0 || port > 65535) {
          renderStatus("请输入合法的 IP 和端口（1-65535）", true);
          return;
        }
        renderStatus("正在设置...");
        try {
          await invoke("set_system_proxy", { host, port });
          renderStatus(`已设置系统代理为 ${host}:${port}`);
          refreshSaved(); // 设置成功后，刷新一下“原代理”的显示
        } catch (e) {
          console.error(e);
          renderStatus(`设置失败：${e}`, true);
        }
      });

      // “恢复原代理”按钮点击事件
      document.getElementById("restore").addEventListener("click", async () => {
        const invoke = await getInvoke();
        if (!invoke) return;
        renderStatus("正在恢复原代理/关闭代理...");
        try {
          await invoke("restore_system_proxy");
          renderStatus("已恢复原代理（若无记录则已关闭）");
          refreshSaved(); // 恢复后，“原代理”记录理论上被清空了
        } catch (e) {
          console.error(e);
          renderStatus(`恢复失败：${e}`, true);
        }
      });

      // “获取当前代理”按钮点击事件
      document.getElementById("current").addEventListener("click", async () => {
        const invoke = await getInvoke();
        if (!invoke) return;
        renderCurrent(null, "获取中...");
        try {
          const data = await invoke("get_current_proxy");
          renderCurrent(data, "已获取");
        } catch (e) {
          console.error(e);
          renderCurrent(null, "获取失败");
        }
      });

      // --- 初始化 ---
      // 页面加载后立即启动代理变化监听
      setupProxyChangeListener();
      // 并获取一次已保存的代理信息
      refreshSaved();
    </script>
  </body>
</html>
